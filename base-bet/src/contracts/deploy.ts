import { ethers } from 'ethers';
import { config } from '../utils/config';
import { Logger } from '../utils/logger';
import fs from 'fs';
import path from 'path';

async function deployContract() {
  Logger.info('ğŸš€ Starting contract deployment...');

  // Initialize provider based on network
  let provider: ethers.Provider;
  if (config.blockchain.network === 'base-mainnet') {
    provider = new ethers.JsonRpcProvider('https://mainnet.base.org');
  } else {
    provider = new ethers.JsonRpcProvider('https://sepolia.base.org');
  }

  // Initialize wallet
  const wallet = new ethers.Wallet(config.agentkit.privateKey, provider);
  Logger.info(`ğŸ“ Deploying to: ${config.blockchain.network}`);
  Logger.info(`ğŸ”‘ From address: ${wallet.address}`);

  // Check balance
  const balance = await provider.getBalance(wallet.address);
  Logger.info(`ğŸ’° Wallet balance: ${ethers.formatEther(balance)} ETH`);

  if (balance < ethers.parseEther('0.01')) {
    Logger.error('âŒ Insufficient balance for deployment. Need at least 0.01 ETH.');
    process.exit(1);
  }

  try {
    // Read contract source
    const contractPath = path.join(__dirname, 'PredictionBetting.sol');
    const contractSource = fs.readFileSync(contractPath, 'utf8');

    // For production, you would use a proper Solidity compiler
    // This is a simplified version - in practice, use hardhat or foundry
    Logger.warn('âš ï¸  Using simplified deployment. For production, use Hardhat or Foundry.');

    // Contract bytecode and ABI would be generated by proper compiler
    // This is a placeholder implementation
    const contractFactory = {
      bytecode: '0x608060405234801561001057600080fd5b50336000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550610100565b60006020810190506001600160a01b03831681526020810192909252604081019190915260600190565b604051806020016040528060006001600160a01b0316815250905056fe',
      abi: [
        "function createMarket(string memory tweetId, string memory prediction, uint256 durationDays) external",
        "function placeBet(string memory tweetId, bool position) external payable",
        "function resolveMarket(string memory tweetId, bool outcome) external",
        "function getMarketInfo(string memory tweetId) external view returns (string memory, uint256, bool, bool, uint256, uint256, uint256)",
        "function getUserBets(string memory tweetId, address user) external view returns (uint256[] memory, bool[] memory)",
        "function withdraw() external",
        "function pendingWithdrawals(address) external view returns (uint256)",
        "function marketExists(string memory) external view returns (bool)",
        "function owner() external view returns (address)",
        "function platformFee() external view returns (uint256)",
        "function setPlatformFee(uint256 _fee) external",
        "event MarketCreated(string indexed tweetId, string prediction, address creator, uint256 deadline)",
        "event BetPlaced(string indexed tweetId, address bettor, uint256 amount, bool position)",
        "event MarketResolved(string indexed tweetId, bool outcome)",
        "event Withdrawal(address indexed user, uint256 amount)"
      ]
    };

    // Deploy contract
    const factory = new ethers.ContractFactory(contractFactory.abi, contractFactory.bytecode, wallet);
    
    Logger.info('ğŸ“ Deploying PredictionBetting contract...');
    const contract = await factory.deploy({
      gasLimit: 3000000,
      gasPrice: ethers.parseUnits('20', 'gwei')
    });

    Logger.info('â³ Waiting for deployment confirmation...');
    await contract.waitForDeployment();
    
    const contractAddress = await contract.getAddress();
    Logger.info(`âœ… Contract deployed successfully!`);
    Logger.info(`ğŸ“ Contract address: ${contractAddress}`);
    Logger.info(`ğŸ” View on BaseScan: https://${config.blockchain.network === 'base-mainnet' ? '' : 'sepolia.'}basescan.org/address/${contractAddress}`);

    // Update .env file with contract address
    const envPath = path.join(__dirname, '../..', '.env');
    let envContent = '';
    
    if (fs.existsSync(envPath)) {
      envContent = fs.readFileSync(envPath, 'utf8');
    }
    
    // Update or add CONTRACT_ADDRESS
    const lines = envContent.split('\n');
    let updated = false;
    
    for (let i = 0; i < lines.length; i++) {
      if (lines[i].startsWith('CONTRACT_ADDRESS=')) {
        lines[i] = `CONTRACT_ADDRESS=${contractAddress}`;
        updated = true;
        break;
      }
    }
    
    if (!updated) {
      lines.push(`CONTRACT_ADDRESS=${contractAddress}`);
    }
    
    fs.writeFileSync(envPath, lines.join('\n'));
    Logger.info('ğŸ“ Updated .env file with contract address');

    // Save deployment info
    const deploymentInfo = {
      network: config.blockchain.network,
      contractAddress: contractAddress,
      deployedAt: new Date().toISOString(),
      deployer: wallet.address,
      transactionHash: contract.deploymentTransaction()?.hash
    };

    const deploymentPath = path.join(__dirname, '../..', 'deployment.json');
    fs.writeFileSync(deploymentPath, JSON.stringify(deploymentInfo, null, 2));
    Logger.info('ğŸ“„ Saved deployment info to deployment.json');

    Logger.info('ğŸ‰ Deployment completed successfully!');
    Logger.info('ğŸ“‹ Next steps:');
    Logger.info('1. Update your .env file with the contract address');
    Logger.info('2. Test the contract functions');
    Logger.info('3. Start the Twitter bot');

  } catch (error) {
    Logger.error('ğŸ’¥ Deployment failed:', error);
    process.exit(1);
  }
}

// Run deployment if called directly
if (require.main === module) {
  deployContract().catch(console.error);
}

export { deployContract }; 